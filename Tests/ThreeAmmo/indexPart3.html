<html>
    <head>
        <meta charset="utf-8">
        <title>Collision JS 3D Physics</title>
        <style>
            body { margin: 0; }
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/ammo.js"></script>
        <script>

            //variable declaration section
            let physicsWorld, scene, camera, renderer, rigidBodies = [], pos = new THREE.Vector3(), tmpTrans = null;
            let ball, moveDirection = { left: 0, right: 0, forward: 0, back: 0, up: 0, down: 0 };

            const STATE = { DISABLE_DEACTIVATION : 4 };

            let cbContactResult;
            let redTile, cbContactPairResult;

            //Ammojs Initialization
            Ammo().then(start)

            function start (){

                tmpTrans = new Ammo.btTransform();

                setupPhysicsWorld();

                setupGraphics();

                createFloorTiles();

                createBall();
                createZombie();

                setupContactResultCallback();

                setupContactPairResultCallback();

                setupEventHandlers();
                
                renderFrame();

            }

            function setupPhysicsWorld(){

                let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
                    dispatcher              = new Ammo.btCollisionDispatcher(collisionConfiguration),
                    overlappingPairCache    = new Ammo.btDbvtBroadphase(),
                    solver                  = new Ammo.btSequentialImpulseConstraintSolver();

                physicsWorld           = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
                physicsWorld.setGravity(new Ammo.btVector3(0, -10, 0));

            }


            function setupGraphics(){

                //create clock for timing
                clock = new THREE.Clock();

                //create the scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xabfeff );
                scene.updateMatrixWorld(true)

                //create camera
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 5000 );
                camera.position.set( 0, 80, 40 );
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                //Add hemisphere light
                let hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.1 );
                hemiLight.color.setHSL( 0.6, 0.6, 0.6 );
                hemiLight.groundColor.setHSL( 0.1, 1, 0.4 );
                hemiLight.position.set( 0, 50, 0 );
                scene.add( hemiLight );

                //Add directional light
                let dirLight = new THREE.DirectionalLight( 0xffffff , 1);
                dirLight.color.setHSL( 0.1, 1, 0.95 );
                dirLight.position.set( -1, 1.75, 1 );
                dirLight.position.multiplyScalar( 100 );
                scene.add( dirLight );

                dirLight.castShadow = true;

                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;

                let d = 50;

                dirLight.shadow.camera.left = -d;
                dirLight.shadow.camera.right = d;
                dirLight.shadow.camera.top = d;
                dirLight.shadow.camera.bottom = -d;

                dirLight.shadow.camera.far = 13500;

                //Setup the renderer
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setClearColor( 0xbfd1e5 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                renderer.gammaInput = true;
                renderer.gammaOutput = true;

                renderer.shadowMap.enabled = true;

            }

        
            function renderFrame(){

                let deltaTime = clock.getDelta();

                moveBall();
    

                updatePhysics( deltaTime );

                renderer.render( scene, camera );

                requestAnimationFrame( renderFrame );

            }


            function setupEventHandlers(){

                window.addEventListener( 'resize', onWindowResize, false );
                window.addEventListener( 'keydown', handleKeyDown, false);
                window.addEventListener( 'keyup', handleKeyUp, false);

            }


            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            
            function handleKeyDown(event){

                let keyCode = event.keyCode;

                switch(keyCode){

                    case 87: //W: FORWARD
                        moveDirection.forward = 1;
                        break;
                        
                    case 83: //S: BACK
                        moveDirection.back = 1;
                        break;
                        
                    case 65: //A: LEFT
                        moveDirection.left = 1;
                        break;
                        
                    case 68: //D: RIGHT
                        moveDirection.right = 1;
                        break;

                    case 84://T
                        checkContact();
                        break;
                                            
                    case 74://J
                        jump();
                        break;
                        
                }
            }


            function handleKeyUp(event){
                let keyCode = event.keyCode;

                switch(keyCode){
                    case 87: //W: FORWARD
                        moveDirection.forward = 0;
                        break;
                        
                    case 83: //S: BACK
                        moveDirection.back = 0;
                        break;
                        
                    case 65: //A: LEFT
                        moveDirection.left = 0;
                        break;
                        
                    case 68: //D: RIGHT
                        moveDirection.right = 0;
                        break;
                }

            }


            function createFloorTiles(){
                let tiles = [
                    { name: "yellow", color: 0xFFFF00, pos: {x: -20, y: 0, z: 20} },
                    { name: "red", color: 0xFF0000, pos: {x: 20, y: 0, z: 20} },
                    { name: "green", color: 0x008000, pos: {x: 20, y: 0, z: -20} },
                    { name: "blue", color: 0x0000FF, pos: {x: -20, y: 0, z: -20} }
                ]
                
                let scale = {x: 40, y: 6, z: 40};
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 0;

                for (const tile of tiles) {
                        
                    //threeJS Section
                    let pos = tile.pos;
                    let mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: tile.color}));

                    mesh.position.set(pos.x, pos.y, pos.z);
                    mesh.scale.set(scale.x, scale.y, scale.z);

                    mesh.castShadow = true;
                    mesh.receiveShadow = true;

                    mesh.userData.tag = tile.name;

                    scene.add(mesh);


                    //Ammojs Section
                    let transform = new Ammo.btTransform();
                    transform.setIdentity();
                    transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                    transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                    let motionState = new Ammo.btDefaultMotionState( transform );

                    let colShape = new Ammo.btBoxShape( new Ammo.btVector3( scale.x * 0.5, scale.y * 0.5, scale.z * 0.5 ) );
                    colShape.setMargin( 0.05 );

                    let localInertia = new Ammo.btVector3( 0, 0, 0 );
                    colShape.calculateLocalInertia( mass, localInertia );

                    let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                    let body = new Ammo.btRigidBody( rbInfo );

                    body.setFriction(4);
                    body.setRollingFriction(10);

                    physicsWorld.addRigidBody( body );

                    body.threeObject = mesh;

                    if( tile.name == "red"){

                        mesh.userData.physicsBody = body;
                        redTile = mesh;

                    } 
                    
                }

            }


            function createBall(){
                let pos = {x: 5, y: 6, z: 5};
                let scale = {x: 1, y: 2, z: 1};
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 1;

                //threeJS Section
                ball = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xa0afa4}));

                ball.position.set(pos.x, pos.y, pos.z);
                ball.scale.set(scale.x, scale.y, scale.z);
                ball.userData.tag = "targetItem_zombie"        

                ball.castShadow = true;
                ball.receiveShadow = true;

                scene.add(ball);


                        
                            
                      

                /////////////////////////
                // ----------------AMMOJS
                let transform = new Ammo.btTransform()  
                transform.setIdentity()
                // Position
                transform.setOrigin( new Ammo.btVector3( 
                    pos.x,
                    pos.y,
                    pos.z
                ));
                // Rotation
                transform.setRotation( new Ammo.btQuaternion( 
                    quat.x,
                    quat.y,
                    quat.z,
                    quat.w,
                ));
                let motionState = new Ammo.btDefaultMotionState( transform );
                // Hitbox
                let colShape = new Ammo.btBoxShape( new Ammo.btVector3( 
                    scale.x * 0.5, 
                    scale.y * 0.5, 
                    scale.z * 0.5, 
                ));
                colShape.setMargin( 0.05 );
                // Inertie
                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );
                // Création de l'element physique, avec ses attributs
                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );                        
                // Ajout du body au monde physique, avec contraintes de colisions
                physicsWorld.addRigidBody( body );


                body.setFriction(4);
                body.setRollingFriction(10);

                rigidBodies.push(ball)
                ball.userData.physicsBody = body
                body.threeObject = ball
                
            }

            function createZombie(){


                let pos = {x: 5, y: 6, z: 5};
                let scale = {x: 7, y: 7, z: 7};
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 1;

                //threeJS Section
                let blockPlane = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xa0afa4}));

                blockPlane.position.set(pos.x, pos.y, pos.z);
                blockPlane.scale.set(scale.x, scale.y, scale.z);
                blockPlane.userData.tag = "targetItem_zombie"        

                blockPlane.castShadow = true;
                blockPlane.receiveShadow = true;

                scene.add(blockPlane);


                        
                            
                      

                /////////////////////////
                // ----------------AMMOJS
                let transform = new Ammo.btTransform()  
                transform.setIdentity()
                // Position
                transform.setOrigin( new Ammo.btVector3( 
                    pos.x,
                    pos.y,
                    pos.z
                ));
                // Rotation
                transform.setRotation( new Ammo.btQuaternion( 
                    quat.x,
                    quat.y,
                    quat.z,
                    quat.w,
                ));
                let motionState = new Ammo.btDefaultMotionState( transform );
                // Hitbox
                let colShape = new Ammo.btBoxShape( new Ammo.btVector3( 
                    scale.x * 0.5, 
                    scale.y * 0.5, 
                    scale.z * 0.5, 
                ));
                colShape.setMargin( 0.05 );
                // Inertie
                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );
                // Création de l'element physique, avec ses attributs
                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );                        
                // Ajout du body au monde physique, avec contraintes de colisions
                physicsWorld.addRigidBody( body );


                body.setFriction(4);
                body.setRollingFriction(10);

                rigidBodies.push(blockPlane)
                blockPlane.userData.physicsBody = body
                body.threeObject = blockPlane
                
            }

            function setupContactResultCallback(){

                cbContactResult = new Ammo.ConcreteContactResultCallback();
                cbContactResult.addSingleResult = function(cp, colObj0Wrap, partId0, index0, colObj1Wrap, partId1, index1){
                    
                    let contactPoint = Ammo.wrapPointer( cp, Ammo.btManifoldPoint );

                    const distance = contactPoint.getDistance();
                    // console.log("distance :", distance)
                    if( distance > 0 ) return;

                    let colWrapper0 = Ammo.wrapPointer( colObj0Wrap, Ammo.btCollisionObjectWrapper );
                    let rb0 = Ammo.castObject( colWrapper0.getCollisionObject(), Ammo.btRigidBody );
                    
                    let colWrapper1 = Ammo.wrapPointer( colObj1Wrap, Ammo.btCollisionObjectWrapper );
                    let rb1 = Ammo.castObject( colWrapper1.getCollisionObject(), Ammo.btRigidBody );

                    let threeObject0 = rb0.threeObject;
                    let threeObject1 = rb1.threeObject;

                    let tag, localPos, worldPos

                    if( threeObject0.userData.tag != "ball" ){

                        tag = threeObject0.userData.tag;
                        localPos = contactPoint.get_m_localPointA();
                        worldPos = contactPoint.get_m_positionWorldOnA();

                    }
                    else{

                        tag = threeObject1.userData.tag;
                        localPos = contactPoint.get_m_localPointB();
                        worldPos = contactPoint.get_m_positionWorldOnB();

                    }
                    
                    let localPosDisplay = {x: localPos.x(), y: localPos.y(), z: localPos.z()};
                    let worldPosDisplay = {x: worldPos.x(), y: worldPos.y(), z: worldPos.z()};

                    // console.log( { tag, localPosDisplay, worldPosDisplay } );
                    
                }

            }


            function setupContactPairResultCallback(){

                cbContactPairResult = new Ammo.ConcreteContactResultCallback();
                
                cbContactPairResult.hasContact = false;

                cbContactPairResult.addSingleResult = function(cp, colObj0Wrap, partId0, index0, colObj1Wrap, partId1, index1){
                    
                    let contactPoint = Ammo.wrapPointer( cp, Ammo.btManifoldPoint );

                    const distance = contactPoint.getDistance();

                    if( distance > 0 ) return;

                    this.hasContact = true;
                    
                }

            }



            function moveBall(){

                let scalingFactor = 20;

                let moveX =  moveDirection.right - moveDirection.left;
                let moveZ =  moveDirection.back - moveDirection.forward;

                if( moveX == 0 && moveZ == 0) return;

                let resultantImpulse = new Ammo.btVector3( moveX, 0, moveZ )
                resultantImpulse.op_mul(scalingFactor);

                let physicsBody = ball.userData.physicsBody;
                physicsBody.setLinearVelocity( resultantImpulse );

            }


            function checkContact(){

                physicsWorld.contactTest( ball.userData.physicsBody , cbContactResult );

            }


            function jump(){

                cbContactPairResult.hasContact = false;

                physicsWorld.contactPairTest(ball.userData.physicsBody, redTile.userData.physicsBody, cbContactPairResult);

                if( !cbContactPairResult.hasContact ) return;

                let jumpImpulse = new Ammo.btVector3( 0, 15, 0 );

                let physicsBody = ball.userData.physicsBody;
                physicsBody.setLinearVelocity( jumpImpulse );

            }

            let rota = 0

            function updatePhysics( deltaTime ){

                // Step world
                physicsWorld.stepSimulation( deltaTime, 10 );

                // Update rigid bodies
                for ( let i = 0; i < rigidBodies.length; i++ ) {
                    let objThree = rigidBodies[ i ];
                    let objAmmo = objThree.userData.physicsBody;
                    let ms = objAmmo.getMotionState();
                    if ( ms ) {

                        ms.getWorldTransform( tmpTrans );
                        let p = tmpTrans.getOrigin();
                        let q = tmpTrans.getRotation();
                        objThree.position.set( p.x(), p.y(), p.z() );
                        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

                    }
                    if(rigidBodies[i].userData.tag == 'targetItem_zombie'){
                        // Position de la camera, l'endroit vers où le zombie regarde
                        let ballPos = new THREE.Vector3();
                        let balll = ball.getWorldPosition(ballPos)
                        let camPosX = balll.x
                        let camPosZ = balll.z
                        // Orientation du cube vers la ball
                        rigidBodies[i].lookAt(camPosX, 0, camPosZ)
                        
                 
                        let scalingFactor = 7;


                        let bodyPosX = rigidBodies[i].modelViewMatrix.elements[12]  // Coord X
                        let bodyPosZ = rigidBodies[i].modelViewMatrix.elements[13]  // Coord Z
                        // Différence entre les 2 objects
                        let diffX = camPosX - bodyPosX
                        let diffZ = camPosZ + bodyPosZ
                        console.log("camPos : ",parseInt(camPosX), parseInt(camPosZ))
                        console.log("bodyPos : ",parseInt(bodyPosX), parseInt(bodyPosZ))
                        // console.log("Diffs : ",parseInt(diffX), parseInt(diffZ))

                        let moveX 
                        let moveZ
                        if(diffX > 0.1){
                            moveX = 1
                        } else if (diffX < -0.1){
                            moveX = -1
                        } else {
                            moveX = 0
                        }
                        if(diffZ > 0.1){
                            moveZ = 1
                        } else if (diffZ < -0.1){
                            moveZ = -1
                        } else {
                            moveZ = 0
                        }
                        
                        // console.log("diffs : ", diffX, diffZ, "\nMoves : ", moveX, moveZ)


                        if( moveX == 0 && moveZ == 0) return;

                        let resultantImpulse = new Ammo.btVector3( moveX, 0, moveZ )
                        resultantImpulse.op_mul(scalingFactor);

                        let physicsBody = rigidBodies[i].userData.physicsBody;
                        physicsBody.setLinearVelocity( resultantImpulse );
                 
                 
                 
                 
                 
                 
                 
                 
                        // // Position du cube
                        // rigidBodies[i].updateMatrixWorld();
                        // // let cubePos = new THREE.Vector3();
                        // // let cuube = rigidBodies[i].getWorldPosition(cubePos)

                        // let bodyPosX = rigidBodies[i].modelViewMatrix.elements[12]  // Coord X
                        // let bodyPosZ = rigidBodies[i].modelViewMatrix.elements[13]  // Coord Z
                        // // console.log(bodyPosX, bodyPosZ)
                        // console.log(rigidBodies[i])
                        // console.log(rigidBodies[i].modelViewMatrix)
                        // // Différence entre les 2 objects
                        // let diffX = camPosX - bodyPosX
                        // let diffZ = camPosZ - bodyPosZ
                        // // Variables de prochaines pos
                        // let nextPosX, nextPosZ
                        // // Déplace en fonction de la difference
                        // if(diffX > 0.01){
                        //     nextPosX = bodyPosX + 0.08                              
                        // } else if (diffX < 0.01){
                        //     nextPosX = bodyPosX - 0.08                    
                        // } else {
                        //     nextPosX = bodyPosX
                        // }
                        // if(diffZ > 0.01){
                        //     nextPosZ = bodyPosZ + 0.8                             
                        // } else if(diffZ < 0.01){
                        //     nextPosZ = bodyPosZ - 0.8                     
                        // } else {
                        //     nextPosZ = bodyPosZ
                        // }

                        // rota += 0.05
                        // // console.log("cube pose : ", bodyPosZ, "\ndiff avec balle : ", diffZ, "\nnext pos : ",  nextPosZ)
                        // // Assigne la nouvelle position
                        // rigidBodies[i].position.set(
                        //     nextPosX,
                        //     6,
                        //     0,
                        // ) 

                    }

                }
                detectCollision();
            }


            function detectCollision(){

                let dispatcher = physicsWorld.getDispatcher();
                let numManifolds = dispatcher.getNumManifolds();

                for ( let i = 0; i < numManifolds; i ++ ) {

                    let contactManifold = dispatcher.getManifoldByIndexInternal( i );
                    let numContacts = contactManifold.getNumContacts();

                    for ( let j = 0; j < numContacts; j++ ) {

                        let contactPoint = contactManifold.getContactPoint( j );
                        let distance = contactPoint.getDistance();
                        if( distance > 0.0 ) continue;
                        // console.log({manifoldIndex: i, contactIndex: j, distance: distance});
                    }
                }
            }


        </script>
    </body>
</html>